# 架构设计哲学

`fe-auto-factory` 的演进不仅仅是一套前端模板代码生成器（Generator），更是对大前端多人协作、效率提上与底层基础设施设计深度思考的沉淀。

## 为什么需要前端自动化架构工厂？

现代前端早已经历了“刀耕火种”的页面拼接时代。当在面临复杂的后台管理中台、高并发的 H5 推广页面时，传统的人工配置 `Vue components` + 复制粘贴 `Service` 层 + 徒手注册路由：
1. **枯燥乏味，没有技术含量**。大把事件消耗在了手写模版代码上（Boilerplate）。
2. **规范易被打破**。高级与初级工程师混合协作，非常容易出现路由管理四分五裂、接口联调类型 ( `any` ) 乱飞、状态工具 (`Vuex` \ `Pinia` 等) 被当做全局状态垃圾桶等等劣质现象。
3. **安全隐患**。经常因为拼写的手误或者漏写 Error Boundary 等情况发生上线后的线上客诉或者白屏崩溃。

**脚手架的目的，正在于以架构设计取代口头规训。所有业务页面在动身敲击键盘之前都必须先设计出符合系统规范的 JSON Schema 图纸才能得到自动化的基础建设支持！**

## 核心工作流解析

### 第一阶段：工厂接入 (Init & Factory Configuration)

业务方在项目中下发 `.factoryrc.json` 。用来标记目前自己本团队的个性化开发目录。以及支持什么组件库。

```json
{
  "viewsDir": "src/pages", // 有的团队不叫 views，叫 pages
  "apiDir": "src/api"
}
```

脚手架核心的 `generator.js` 会在每次生成前扫描读取。将自己变成一个灵活适应其他团队基建生态的宿主形态包容者。

### 第二阶段：规范防御 (Schema validation)

所有生成并非乱敲命令行均可。背后依赖了 **Ajv** 等强类型 `Json/yaml Schema` 识别器技术，如果定义的产出页面连必需的最基本框架（比如页面 ID）都没填写，将在第一步直接挂起抛错。拦截脏数据（Dirty Type Payload）产生的脏源头代码下放！

### 第三阶段：一键产研闭环 (Generate & Testing && Mock sync)

这是技术沉淀的内核：当顺利读取 `yaml Schema` 结构定义之后：
- 通过核心的 `AST / EJS 解析器引擎`，分层次往业务项目的文件池进行**代码输出与替换注入**。
- `Router Inject`: 自动拦截分析 Vue 的 Router 主控树，用极其巧妙的正则（或者 AST 重建）动态塞入这个新生产界面的 import 及 URL。
- 如果引入了后端 OpenAPI 概念，会全自动调用 `fe-factory sync` 解析出 TypeScript `Interface / Type` 的 `.d.ts` 模型。（也就是让前端连定义后端返回值为对象、数组的工作量都免除了！）

---

通过这种强有力、带有安全隔离性的代码自化工厂架构，我们在构建的，其实并不是一个“一键生成器”。而是对无数业务线上沉淀出了一套**标准的产研流水线约束法则**！
